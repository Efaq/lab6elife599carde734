% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/brute_force_knapsack_slow.R
\name{brute_force_knapsack_slow}
\alias{brute_force_knapsack_slow}
\title{Brute force search approach for Knapsack problem - Slow version}
\usage{
brute_force_knapsack_slow(x, W, parallel = FALSE)
}
\arguments{
\item{x, }{data.frame with two variables v and w. Variables should be positive.}

\item{W, }{numeric scalar, represents capacity.}

\item{Parallel, }{TRUE or FALSE. 
\cr Is FALSE by default.If set to TRUE, the function parallelize
over the detected cores.}
}
\value{
value and elements that fill the knapsack with some given items, so that the value of the selected items is maximized.
}
\description{
\code{brute_force_knapsack_slow} uses a "brute force" algorithm in order to solve the knapsack problem. 
Knapsack problem is a discrete optimization problem where we have a knapsack that can take a
limited weight W and we want to fill this knapsack with a number of items i = 1, ..., n, each with a weight wi and a value vi. 
The goal is to find the knapsack with the largest value of the elements added to
the knapsack.\cr \cr Brute force evaluates the total weight and value of all possible subsets, then selects the subset 
with the highest value that is still under the weight limit.
While this is an effective solution, it is not optimal because the time complexity is exponential. \cr \cr  This is a slower/not improved
version of brute_force_knapsack function.
}
\examples{

RNGversion(min(as.character(getRversion()),"3.5.3"))

set.seed(42, kind = "Mersenne-Twister", normal.kind = "Inversion")
n <- 2000
knapsack_objects <-
data.frame(
 w=sample(1:4000, size = n, replace = TRUE),
   v=runif(n = n, 0, 10000)
 )


brute_force_knapsack_slow(x = knapsack_objects[1:8,], W = 3500, parallel=TRUE)
brute_force_knapsack_slow(x = knapsack_objects[1:12,], W = 3500)
brute_force_knapsack_slow(x = knapsack_objects[1:8,], W = 2000)
brute_force_knapsack_slow(x = knapsack_objects[1:12,], W = 2000)


}
